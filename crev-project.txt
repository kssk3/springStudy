Project Directory Structure:
├── ARCHITECTURE.md
├── CLAUDE.md
├── SPRING_LEARNING_CURRICULUM.md
├── context.txt
├── settings.gradle
├── src
│   ├── main
│   │   ├── java
│   │   │   ├── com
│   │   │   │   ├── todoapp
│   │   │   │   │   ├── Application.java
│   │   │   │   │   ├── business
│   │   │   │   │   │   ├── service
│   │   │   │   │   │   │   ├── TodoService.java
│   │   │   │   │   │   │   └── UserService.java
│   │   │   │   │   ├── common
│   │   │   │   │   │   ├── config
│   │   │   │   │   │   │   └── SecurityConfig.java
│   │   │   │   │   │   ├── exception
│   │   │   │   │   │   │   ├── BusinessException.java
│   │   │   │   │   │   │   ├── DuplicateEmailException.java
│   │   │   │   │   │   │   ├── ErrorCode.java
│   │   │   │   │   │   │   └── InvalidCredentialsException.java
│   │   │   │   │   │   ├── security
│   │   │   │   │   │   │   ├── CustomUserDetailService.java
│   │   │   │   │   │   │   └── CustomUserDetails.java
│   │   │   │   │   ├── dataaccess
│   │   │   │   │   │   ├── config
│   │   │   │   │   │   │   └── PasswordEncoderConfig.java
│   │   │   │   │   │   ├── entity
│   │   │   │   │   │   │   ├── BaseEntity.java
│   │   │   │   │   │   │   ├── BaseTimeEntity.java
│   │   │   │   │   │   │   ├── Todo.java
│   │   │   │   │   │   │   └── User.java
│   │   │   │   │   │   ├── repository
│   │   │   │   │   │   │   ├── TodoRepository.java
│   │   │   │   │   │   │   └── UserRepository.java
│   │   │   │   │   ├── implement
│   │   │   │   │   │   ├── validator
│   │   │   │   │   │   │   ├── PasswordMatch.java
│   │   │   │   │   │   │   └── PasswordMatchValidator.java
│   │   │   │   │   ├── pressentation
│   │   │   │   │   │   ├── controller
│   │   │   │   │   │   │   ├── AuthController.java
│   │   │   │   │   │   │   └── TodoController.java
│   │   │   │   │   │   ├── dto
│   │   │   │   │   │   │   ├── request
│   │   │   │   │   │   │   │   ├── LoginRequest.java
│   │   │   │   │   │   │   │   ├── SignUpRequest.java
│   │   │   │   │   │   │   │   └── TodoCreateRequest.java
│   │   │   │   │   │   │   ├── response
│   │   │   │   │   │   │   │   ├── ErrorResponse.java
│   │   │   │   │   │   │   │   ├── LoginResponse.java
│   │   │   │   │   │   │   │   ├── SignUpResponse.java
│   │   │   │   │   │   │   │   └── TodoResponse.java
│   │   │   │   │   │   ├── exception
│   │   │   │   │   │   │   └── GlobalExceptionHandler.java
│   │   │   ├── test
│   │   │   │   ├── Application.java
│   │   │   │   ├── ErrorResponse.java
│   │   │   │   ├── GlobalExceptionHandler.java
│   │   │   │   ├── SignUpRequest.java
│   │   │   │   ├── Todo.java
│   │   │   │   ├── TodoController.java
│   │   │   │   ├── TodoCreateRequest.java
│   │   │   │   ├── TodoRepository.java
│   │   │   │   ├── TodoResponse.java
│   │   │   │   ├── TodoService.java
│   │   │   │   ├── User.java
│   │   │   │   └── UserRepository.java
│   │   ├── resources
│   │   │   ├── application.yml
│   │   │   └── templates
│   ├── test
│   │   ├── java
│   │   │   ├── com
│   │   │   │   ├── todoapp
│   │   │   │   │   ├── ApplicationTests.java
│   │   │   │   │   ├── Integration
│   │   │   │   │   │   ├── TodoIntegrationTest.java
│   │   │   │   │   │   ├── UserLoginIntegrationTest.java
│   │   │   │   │   │   └── UserSignUpIntegrationTest.java
│   │   │   │   │   ├── TodoValidationTest.java
│   │   │   │   │   ├── common
│   │   │   │   │   │   ├── config
│   │   │   │   │   │   │   └── SecurityConfigTest.java
│   │   │   │   │   ├── controller
│   │   │   │   │   │   └── AuthControllerTest.java
│   │   │   ├── test
│   │   │   │   ├── ApplicationTests.java
│   │   │   │   └── TodoValidationTest.java
│   │   └── resources


File: 
ARCHITECTURE.md
Content: 
ARCHITECTURE.md
목표
프로젝트가 커져도 유지보수와 확장이 가능하도록, 코드의 책임을 명확히 나누고 의존성 방향을 통제한다.

특히 “비즈니스 흐름이 읽히는 코드”를 상위 레이어에 두고, DB/외부연동 등 기술 변화에 민감한 상세 구현은 하위 레이어로 격리한다.

레이어 개요
본 프로젝트는 아래 4개 레이어를 사용한다.

* Presentation Layer
* Business Layer
* Implement Layer
* Data Access Layer 
Presentation Layer
  외부로 “노출/요청/응답”을 담당한다.

예: Controller, Request/Response DTO, API 스펙에 종속되는 검증/바인딩 코드.

Business Layer
유스케이스 중심으로 “비즈니스 흐름(단계)이 읽히는 코드”를 배치한다.

예: 회원가입, 결제, 주문 생성처럼 작업의 큰 단계를 오케스트레이션하며, 상세 구현은 Implement/Data Access로 위임한다.

Implement Layer
Business가 위임한 “상세 구현 로직”을 담당한다.

도메인 규칙을 적용하기 위한 도구/컴포넌트(검증, 조합, 계산, 정책, 변환 등)가 주로 위치하며, 프로젝트에서 클래스 수가 가장 많아지기 쉬운 레이어다.

Data Access Layer
DB/외부 시스템 접근을 담당한다.

예: Repository/DAO, 외부 API client, 메시징/캐시/파일 등 인프라 접근 코드.

의존성(참조) 규칙
레이어의 목적은 “분리”보다 “통제”이며, 아래 규칙을 강제한다.

* 의존성 방향은 위 → 아래만 허용한다. 
* 하위 레이어는 상위 레이어를 참조하면 안 된다. 
* 상위 레이어가 중간 레이어를 건너뛰어 하위 레이어를 직접 참조하면 안 된다. 
* 같은 레이어끼리 참조는 원칙적으로 금지한다. 
* 예외: Implement Layer는 협력/재사용을 위해 Implement 내부 상호 참조를 허용한다. 
설계 의도(왜 이렇게 나누나)
                                                                                                                           Service에 로직이 과도하게 몰리면 “비즈니스 흐름”이 사라지고, Repository/기술 세부사항을 너무 많이 알게 되어 변경에 취약해진다.

그래서 Business는 “흐름”, Implement는 “상세 구현”, Data Access는 “기술 의존성”으로 책임을 나눠 변경 이유를 분리한다.

패키지(또는 모듈) 가이드
아래는 단일 모듈 기준의 패키지 예시다(멀티모듈이면 각 레이어를 모듈로 분리 가능).

* ...presentation
    * ...controller
    * ...dto (request/response)
* ...business
    * ...usecase (또는 service)
* ...implement
    * ...policy, ...validator, ...processor, ...factory 등 “상세 구현 컴포넌트”
* ...dataaccess
    * ...repository (JPA 등)
    * ...client (외부 API)
    * ...config (인프라 설정) 
모듈화(선택)
      Data Access처럼 기술 의존성이 강한 영역은 별도 모듈로 분리하고, Gradle 의존성 설정에서 구현체가 상위로 전파되지 않도록 관리한다.

기술 모듈 의존성이 상위로 새어나가면 상위 레이어가 특정 라이브러리/구현체를 직접 참조하게 되어 레이어 오염이 발생할 수 있다.

코드 리뷰 체크리스트
* 이 코드는 어느 레이어에 있어야 하는가? (외부 입출력/흐름/상세구현/데이터접근) 
* 상위 레이어가 하위를 “건너뛰어” 참조하고 있지 않은가? 
* Data Access/외부 연동 타입(JPA Entity/Repository/Client 등)이 Business에 노출되고 있지 않은가? 
* Implement 내부 상호 참조가 과도해져 “새로운 거대한 레이어”가 되지 않았는가? 


File: 
CLAUDE.md
Content: 
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project

- Backend API project using Spring Boot (Java 21)
- Primary goal: **production-quality code** (readable, testable, efficient), not just "works"

## Build & Run Commands

```bash
./gradlew build                                    # Build the project
./gradlew test                                     # Run all tests
./gradlew clean build                              # Clean build
./gradlew bootRun                                  # Start the application
./gradlew test --tests ClassName.methodName        # Run a specific test
./gradlew test --tests ClassName                   # Run all tests in a class
```

## Non-negotiable Rules (MUST)

1. Do not output "working-only" code. Always optimize for clarity + maintainability + predictable performance.
2. Avoid unnecessary work: no redundant loops, redundant allocations, redundant conversions, redundant branching, or repeated getter calls without justification.
3. Keep error handling consistent: use ErrorCode for code/message/status; no hardcoded literals.
4. If you change behavior/contract, call it out explicitly and ask before proceeding.
5. Prefer deterministic code paths: parsing/validation/formatting should be plain code, not "clever" patterns that hide cost.

## Refactor Standard (default expectation)

Whenever you edit existing code, you MUST:
1. Provide the refactored code.
2. Explain: what was wasteful or risky, and how you removed it (2-5 bullets).
3. Provide a small verification plan: tests to add or how to run existing tests.

## Performance Checklist

When writing or refactoring code, check these (in order):
- Remove repeated computation / repeated access (e.g., calling the same method multiple times)
- Avoid pre-check patterns that duplicate work (e.g., `hasXxx()` then `getXxx()`) unless you prove benefit
- Minimize passes over collections: aim for one pass when building maps/lists
- Avoid intermediate collections unless they improve clarity AND cost is negligible
- For hot paths, prefer simple loops; for cold paths, prioritize readability but still avoid obvious waste

## Architecture

### Package Structure (com.todoapp)

```
com.todoapp/
├── business/service/      # Business logic (@Service, @Transactional)
├── common/
│   ├── config/            # Spring configurations (PasswordEncoderConfig)
│   └── exception/         # ErrorCode enum, BusinessException
├── domain/                # JPA entities (extend BaseTimeEntity)
├── implement/repository/  # Spring Data JPA repositories
├── pressentation/
│   ├── controller/        # REST controllers (@RestController)
│   ├── dto/request/       # Request DTOs with validation
│   ├── dto/response/      # Response DTOs
│   └── exception/         # GlobalExceptionHandler (@RestControllerAdvice)
└── validation/            # Custom validators (PasswordMatch, etc.)
```

### Entity Hierarchy

All entities extend `BaseTimeEntity` which provides:
- `id` (from BaseEntity) - auto-generated Long
- `createdDate`, `updatedDate` (from BaseTimeEntity) - JPA auditing with Instant

### Exception Handling

- `ErrorCode` enum defines all error codes with HttpStatus, code, and message
- `BusinessException` wraps ErrorCode for business logic errors
- `GlobalExceptionHandler` handles validation errors and business exceptions
- For validation errors: build error map in single transformation, define key-collision policy explicitly

### Password Validation

Uses regex pattern for validation:
```java
@Pattern(regexp = "^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[!@#$%^&*(),.?\":{}|<>]).{8,20}$")
```
Passwords are encrypted with BCryptPasswordEncoder.

## Key Technologies

- **Spring Boot 4.0.1** (Java 21)
- **Spring Data JPA** with H2 in-memory database
- **Jakarta Validation** for bean validation
- **Lombok** for boilerplate reduction
- **passay** for password validation rules

## H2 Console

URL: `http://localhost:8080/h2-console`
- JDBC URL: `jdbc:h2:mem:testdb`
- Username: `sa`
- Password: (empty)

## REST API

**Todo API** (`/api/todos`):
- `POST /api/todos` - Create todo
- `GET /api/todos` - Get all todos
- `GET /api/todos/{id}` - Get todo by ID
- `PATCH /api/todos/{id}/complete` - Mark complete
- `DELETE /api/todos/{id}` - Delete todo

**Auth API**:
- `POST /api/auth/signup` - User registration
- `POST /api/auth/login` - User login

## Code Writing Principles

1. **Consistency** - Use the same patterns across similar methods within a class. If one method validates existence before operating, all similar methods should do the same.

2. **Defensive Programming** - Always handle edge cases: non-existent resources, invalid inputs, null values. Never assume the happy path.

3. **Explainable Code** - Write code that can answer "why did you do it this way?" in a code review. Every design decision should be justifiable.

4. **Fail Fast** - Validate early and throw meaningful exceptions. Silent failures (like `deleteById` ignoring non-existent IDs) should be avoided.

5. **No Hardcoding** - If a value is defined in an enum, constant, or config, always use that reference. Never duplicate values as string literals or magic numbers.

6. **Avoid unnecessary work** - Don’t add redundant pre-checks. Because getFieldErrors()/getGlobalErrors() generally yield empty lists rather than null, default to a single-pass transformation. Use hasFieldErrors()/hasGlobalErrors() only when it clearly reduces work (e.g., avoiding an expensive transformation) or materially improves readability.

7. **Extract Repeated Calls** - If calling the same method multiple times (e.g., `e.getBindingResult()`), extract it to a local variable.

8. **Production-Ready from Start** - Write code as if it will be deployed immediately. No "quick fix now, improve later" mindset.

## Java Style Preferences

- Prefer small pure functions for transformations (e.g., `BindingResult -> Map<String,String>`)
- Prefer immutability by default (`final`), unless mutation improves clarity/performance
- Keep methods short and named by intent (what/why, not how)
- Spring Boot 어노테이션 사용 시 해당 어노테이션의 역할을 한 줄로 간략히 설명할 것

## Testing Expectations

- **테스트 우선 워크플로우**: 구현 코드보다 테스트 코드를 먼저 제안하고, 사용자가 검토/승인한 뒤에 구현 코드를 작성한다
- If you introduce or modify logic, propose unit tests (JUnit5)
- For exception handlers, include tests for: field errors only, global errors only, mixed, duplicate keys policy
- Run `./gradlew test` to verify all tests pass before committing

## Code Explanation Guidelines

코드를 설명할 때 반드시 아래 순서를 따른다:

1. **비유로 시작** - 일상생활의 무언가에 비유하여 핵심 개념을 잡는다
2. **다이어그램** - ASCII art로 흐름, 구조, 관계를 시각화한다
3. **코드 워크스루** - 단계별로 무슨 일이 일어나는지 설명한다
4. **주의점(gotcha)** - 흔한 실수나 오해하기 쉬운 부분을 짚는다

- 설명은 대화체로 작성하고, 복잡한 개념은 여러 비유를 활용한다

## Interaction Protocol

- **완성 코드를 바로 제공하지 않는다** - 사용자가 명시적으로 요청하기 전까지 완성된 구현 코드를 주지 않는다
- If the task is ambiguous, ask 1-3 clarifying questions before coding
- Otherwise, implement the smallest correct change first, then propose improvements as optional follow-ups
- When you propose a "better" solution, include trade-offs (readability vs allocations vs extensibility)


File: 
SPRING_LEARNING_CURRICULUM.md
Content: 
# Spring Boot 실전 학습 커리큘럼

> 현재 TodoApp 프로젝트 상태 기반 단계별 학습 가이드

---

## 현재 프로젝트 상태

### ✅ 구현 완료
- Todo CRUD API (`TodoController`, `TodoService`)
- Todo 엔티티 및 Repository
- User 엔티티 (email unique 제약조건 포함)
- UserRepository (`findByEmail`, `existsByEmail`)
- 회원가입 요청 검증 (`SignUpRequest`, `@Password`, `@PasswordMatch`)
- GlobalExceptionHandler (기본 예외 처리)
- 통합 테스트 (`TodoIntegrationTest`)

### ❌ 미구현 (학습 대상)
- BaseTimeEntity (JPA Auditing)
- UserService (회원가입 로직)
- AuthController (회원가입 API)
- PasswordEncoderConfig (비밀번호 암호화)
- 커스텀 예외 계층 (ErrorCode, BusinessException)
- 단위 테스트 (Service 레이어)
- 로깅
- 환경 설정 분리
- Spring Security / JWT

---

## Phase 1: 회원가입 기능 완성

### 1.1 비밀번호 암호화 설정

**학습 목표**: Spring Security의 PasswordEncoder 설정

**현재 상태**
- `PasswordEncoderConfig.java`가 빈 클래스로 존재
- `build.gradle`에 `spring-security-crypto` 의존성 없음

**학습 내용**
- BCryptPasswordEncoder란?
- 단방향 해시 함수의 특징
- Salt의 역할

**실습 과제**
1. `build.gradle`에 의존성 추가
   ```groovy
   implementation 'org.springframework.security:spring-security-crypto'
   ```
2. `PasswordEncoderConfig`에 Bean 등록
3. 테스트로 암호화 동작 확인

---

### 1.2 UserService 구현

**학습 목표**: Service 레이어 작성 및 트랜잭션 관리

**현재 상태**
- `UserService.java`가 빈 클래스로 존재
- `UserRepository`는 구현 완료

**학습 내용**
- `@Service`, `@Transactional` 어노테이션
- 의존성 주입 (Constructor Injection)
- 비즈니스 로직에서 예외 처리

**실습 과제**
1. `signUp(SignUpRequest request)` 메서드 구현
   - 이메일 중복 검사
   - 비밀번호 암호화
   - User 엔티티 생성 및 저장
2. 중복 이메일 시 예외 발생시키기

---

### 1.3 AuthController 구현

**학습 목표**: REST API 엔드포인트 작성

**현재 상태**
- `AuthController.java`가 빈 클래스로 존재
- `SignUpResponse.java`가 빈 클래스로 존재

**학습 내용**
- `@RestController`, `@RequestMapping`
- `@Valid`를 통한 요청 검증
- `ResponseEntity` 사용법

**실습 과제**
1. `SignUpResponse` DTO 작성 (id, message 필드)
2. `POST /api/auth/signup` 엔드포인트 구현
3. Postman 또는 curl로 회원가입 테스트

---

### 1.4 DuplicateEmailException 구현

**학습 목표**: 커스텀 예외 클래스 작성

**현재 상태**
- `DuplicateEmailException.java`가 빈 클래스로 존재
- `GlobalExceptionHandler`에서 처리 로직 없음

**학습 내용**
- RuntimeException 상속
- `@ExceptionHandler`로 예외 처리

**실습 과제**
1. `DuplicateEmailException` 구현 (RuntimeException 상속)
2. `GlobalExceptionHandler`에 핸들러 추가
3. HTTP 409 Conflict 응답 반환

---

## Phase 2: 코드 품질 개선

### 2.1 BaseTimeEntity 구현 (JPA Auditing)

**학습 목표**: 엔티티의 생성/수정 시간 자동 관리

**현재 상태**
- `BaseTimeEntity.java`가 빈 클래스로 존재
- `Todo`, `User`가 BaseTimeEntity 상속 중이나 동작 안 함

**학습 내용**
- `@MappedSuperclass`
- `@CreatedDate`, `@LastModifiedDate`
- `@EnableJpaAuditing` 설정

**실습 과제**
1. `BaseTimeEntity`에 createdAt, modifiedAt 필드 추가
2. Application 클래스에 `@EnableJpaAuditing` 추가
3. Todo 생성 시 createdAt 자동 설정 확인

---

### 2.2 커스텀 예외 계층 설계

**학습 목표**: 체계적인 예외 처리 구조 만들기

**현재 상태**
- GlobalExceptionHandler가 ErrorCode를 참조하나 없음
- 예외마다 일관성 없는 처리

**학습 내용**
- ErrorCode Enum 패턴
- 추상 BusinessException 클래스
- 예외 계층 구조 설계

**실습 과제**
1. `ErrorCode` enum 생성 (HTTP 상태, 코드, 메시지)
2. `BusinessException` 추상 클래스 생성
3. `DuplicateEmailException`이 BusinessException 상속하도록 수정
4. GlobalExceptionHandler 개선

---

### 2.3 로깅 추가

**학습 목표**: 효과적인 로깅 전략 수립

**현재 상태**
- TodoService에 로깅 있음
- UserService, AuthController에 로깅 없음

**학습 내용**
- 로그 레벨 (ERROR, WARN, INFO, DEBUG)
- `@Slf4j` 어노테이션
- 적절한 로그 메시지 작성

**실습 과제**
1. UserService에 `@Slf4j` 추가
2. 회원가입 요청/완료/실패 로그 추가
3. application.yml에 로깅 설정

---

## Phase 3: 테스트 작성

### 3.1 Service 단위 테스트

**학습 목표**: Mockito를 활용한 단위 테스트 작성

**현재 상태**
- 통합 테스트만 존재
- Service 레이어 단위 테스트 없음

**학습 내용**
- `@ExtendWith(MockitoExtension.class)`
- `@Mock`, `@InjectMocks`
- `given().willReturn()` 패턴

**실습 과제**
1. `UserServiceTest` 클래스 생성
2. 회원가입 성공 케이스 테스트
3. 중복 이메일 실패 케이스 테스트

---

### 3.2 Controller 테스트

**학습 목표**: MockMvc를 활용한 API 테스트

**현재 상태**
- `AuthControllerTest.java`가 빈 클래스로 존재

**학습 내용**
- `@WebMvcTest` vs `@SpringBootTest`
- `MockMvc` 사용법
- JSON 요청/응답 검증

**실습 과제**
1. `AuthControllerTest` 구현
2. 회원가입 성공 테스트
3. 유효성 검증 실패 테스트
4. 중복 이메일 테스트

---

## Phase 4: 환경 설정

### 4.1 환경별 설정 분리 (Profile)

**학습 목표**: 개발/운영 환경 분리

**현재 상태**
- application.yml 하나만 존재
- ddl-auto: create (운영에 부적합)

**학습 내용**
- Spring Profile 개념
- application-{profile}.yml
- 환경별 설정 차이

**실습 과제**
1. `application-dev.yml` 생성 (H2, SQL 로그)
2. `application-prod.yml` 생성 (보안 설정)
3. Profile 활성화 방법 실습

---

## Phase 5: 보안 (선택)

### 5.1 Spring Security 기초

**학습 목표**: 인증/인가 기본 개념 이해

**학습 내용**
- SecurityFilterChain 설정
- URL별 접근 권한
- CSRF 설정

**실습 과제**
1. spring-boot-starter-security 의존성 추가
2. SecurityConfig 작성
3. 회원가입 API는 허용, 나머지는 인증 필요

---

### 5.2 JWT 인증 구현

**학습 목표**: 토큰 기반 인증 구현

**학습 내용**
- JWT 구조 (Header.Payload.Signature)
- 토큰 생성/검증
- JwtAuthenticationFilter

**실습 과제**
1. 로그인 API 구현
2. JwtTokenProvider 구현
3. 인증 필터 적용

---

## Phase 6: 고급 주제 (선택)

### 6.1 API 문서화 (Swagger)

**실습 과제**
1. springdoc-openapi 의존성 추가
2. Controller에 `@Operation`, `@Tag` 어노테이션
3. Swagger UI 접속 확인

---

### 6.2 공통 응답 형식

**실습 과제**
1. `ApiResponse<T>` 제네릭 클래스 생성
2. 모든 응답을 ApiResponse로 래핑

---

## 학습 순서 권장

| 순서 | Phase | 난이도 | 예상 소요 |
|:----:|-------|:------:|:--------:|
| 1 | 1.1 비밀번호 암호화 | ★☆☆☆☆ | 30분 |
| 2 | 1.2 UserService | ★★☆☆☆ | 1시간 |
| 3 | 1.3 AuthController | ★★☆☆☆ | 30분 |
| 4 | 1.4 DuplicateEmailException | ★☆☆☆☆ | 30분 |
| 5 | 2.1 BaseTimeEntity | ★★☆☆☆ | 30분 |
| 6 | 2.2 커스텀 예외 계층 | ★★★☆☆ | 1시간 |
| 7 | 2.3 로깅 | ★☆☆☆☆ | 30분 |
| 8 | 3.1 Service 단위 테스트 | ★★★☆☆ | 1시간 |
| 9 | 3.2 Controller 테스트 | ★★☆☆☆ | 1시간 |
| 10 | 4.1 환경 설정 분리 | ★☆☆☆☆ | 30분 |
| 11 | 5.1 Security 기초 | ★★★☆☆ | 2시간 |
| 12 | 5.2 JWT 인증 | ★★★★☆ | 3시간 |

---

## 체크리스트

### Phase 1: 회원가입 기능 완성
- [ ] 1.1 비밀번호 암호화 설정
- [ ] 1.2 UserService 구현
- [ ] 1.3 AuthController 구현
- [ ] 1.4 DuplicateEmailException 구현

### Phase 2: 코드 품질 개선
- [ ] 2.1 BaseTimeEntity (JPA Auditing)
- [ ] 2.2 커스텀 예외 계층 설계
- [ ] 2.3 로깅 추가

### Phase 3: 테스트 작성
- [ ] 3.1 Service 단위 테스트
- [ ] 3.2 Controller 테스트

### Phase 4: 환경 설정
- [ ] 4.1 환경별 설정 분리

### Phase 5: 보안 (선택)
- [ ] 5.1 Spring Security 기초
- [ ] 5.2 JWT 인증 구현

### Phase 6: 고급 주제 (선택)
- [ ] 6.1 API 문서화
- [ ] 6.2 공통 응답 형식

---

## 참고 자료

- [Spring Boot 공식 문서](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Spring Data JPA 레퍼런스](https://docs.spring.io/spring-data/jpa/reference/jpa.html)
- [Baeldung Spring 튜토리얼](https://www.baeldung.com/spring-tutorial)


File: 
context.txt
Content: 

--- build.gradle ---
plugins {
    id 'java'
    id 'org.springframework.boot' version '4.0.1'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
description = 'spring_test'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-h2console'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-webmvc'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.security:spring-security-crypto'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webmvc-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // passay
    implementation "org.passay:passay:1.6.6"
}

tasks.named('test') {
    useJUnitPlatform()
}


File: 
settings.gradle
Content: 
rootProject.name = 'demo'


File: 
src/main/java/com/todoapp/Application.java
Content: 
package com.todoapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}


File: 
src/main/java/com/todoapp/business/service/TodoService.java
Content: 
package com.todoapp.business.service;

import com.todoapp.dataaccess.entity.Todo;
import com.todoapp.dataaccess.repository.TodoRepository;
import com.todoapp.pressentation.dto.request.TodoCreateRequest;
import com.todoapp.pressentation.dto.response.TodoResponse;
import java.util.List;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class TodoService {

    private final TodoRepository todoRepository;

    @Transactional
    public TodoResponse createTodo(TodoCreateRequest request) {
        Todo todo = new Todo(request.getTitle(), request.getDescription());

        Todo savedTodo = todoRepository.save(todo);
        return TodoResponse.from(savedTodo);
    }

    public TodoResponse findById(Long id) {
        Todo todo = todoRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Todo not found"));

        return TodoResponse.from(todo);
    }
    
    public List<TodoResponse> findAll() {
        return todoRepository.findAll().stream()
                .map(TodoResponse::from)
                .toList();
    }

    @Transactional
    public void completeTodo(Long id) {
        Todo todo = todoRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Todo not found"));

        todo.complete();
    }

    @Transactional
    public void deleteTodo(Long id) {
        Todo todo = todoRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Todo not found"));

        todoRepository.delete(todo);
    }
}


File: 
src/main/java/com/todoapp/business/service/UserService.java
Content: 
package com.todoapp.business.service;

import com.todoapp.common.exception.InvalidCredentialsException;
import com.todoapp.dataaccess.entity.User;
import com.todoapp.pressentation.dto.request.LoginRequest;
import com.todoapp.pressentation.dto.request.SignUpRequest;
import com.todoapp.dataaccess.repository.UserRepository;
import com.todoapp.pressentation.dto.response.LoginResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Transactional
    public User signUp(SignUpRequest request) {
        // 이메일 중복 체크
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new IllegalArgumentException("Email already exists");
        }

        String encodePassword = passwordEncoder.encode(request.getPassword());

        // User Entity create
        User user = User.builder()
                .email(request.getEmail())
                .password(encodePassword)
                .name(request.getName())
                .phoneNumber(request.getPhoneNumber())
                .build();

        return userRepository.save(user);
    }

    /**
     * 로그인 - 이메일과 비밀번호로 사용자 인
     *
     * @param request 로그인 요청 (이메일, 비밀번호)
     * @return LoginResponse 로그인 성공 정보
     * @throws InvalidCredentialsException 이메일 또는 비밀번호 불일치
     */
    public LoginResponse login(LoginRequest request) {
        // 1단계 이메일로 사용자 찾기
        User user = userRepository.findByEmail(request.getEmail()).orElseThrow(InvalidCredentialsException::new);

        if(!passwordEncoder.matches(request.getPassword(), user.getPassword())){
            throw new InvalidCredentialsException();
        }

        return LoginResponse.of(user);
    }
}


File: 
src/main/java/com/todoapp/common/config/SecurityConfig.java
Content: 
package com.todoapp.common.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.HttpStatusEntryPoint;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // REST API에서는 필요 없음 CSRF 비활성화
        http.csrf(csrf -> csrf.disable())

                // 세선 사용 안 함
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // URL별 접근 권한 설정
                .authorizeHttpRequests(auth ->
                        auth.requestMatchers("/api/auth/signup", "/api/auth/login").permitAll()
                        .requestMatchers("/h2-console/**").permitAll()
                        .anyRequest().authenticated())
                .exceptionHandling(exception ->
                        exception.authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)))

                .headers(headers -> headers.frameOptions(frame -> frame.disable()));

        return http.build();
    }

    /**
     * AuthenticationProvider 설정
     * UserDetailService와 PasswordEncoder를 연결
     */
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder);
        return provider;
    }

    /**
     * AuthenticationManager Bean 등록
     * 로그인 처리에 필요
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) {
        return configuration.getAuthenticationManager();
    }
}


File: 
src/main/java/com/todoapp/common/exception/BusinessException.java
Content: 
package com.todoapp.common.exception;

import lombok.Getter;

@Getter
public abstract class BusinessException extends RuntimeException {

    private final ErrorCode errorCode;

    protected BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }

    protected BusinessException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}


File: 
src/main/java/com/todoapp/common/exception/DuplicateEmailException.java
Content: 
package com.todoapp.common.exception;

public class DuplicateEmailException extends BusinessException {

    public DuplicateEmailException() {
        super(ErrorCode.DUPLICATE_EMAIL);
    }

    public DuplicateEmailException(String email) {
        super(ErrorCode.DUPLICATE_EMAIL, "이미 사용 중인 이메일입니다: " + email);
    }
}


File: 
src/main/java/com/todoapp/common/exception/ErrorCode.java
Content: 
package com.todoapp.common.exception;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;

@Getter
@RequiredArgsConstructor
public enum ErrorCode {
    // 400 Bad Request
    INVALID_INPUT_VALUE(HttpStatus.BAD_REQUEST, "E001", "잘못된 입력값입니다."),

    // 401 인증/인가 에러
    INVALID_CREDENTIALS(HttpStatus.UNAUTHORIZED, "A001", "이메일 또는 비밀번호가 일치하지 않습니다."),
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, "A002", "존재하지 않는 사용자입니다."),

    // 409 Conflict
    DUPLICATE_EMAIL(HttpStatus.CONFLICT, "E002", "이미 사용 중인 이메일입니다."),

    // 404 Not Found
    TODO_NOT_FOUND(HttpStatus.NOT_FOUND, "E003", "Todo 찾을 수 없습니다."),

    // 500 Internal Server Error
    INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "E999", "서버 오류가 발생했습니다.");



    private final HttpStatus status;
    private final String code;
    private final String message;
}


File: 
src/main/java/com/todoapp/common/exception/InvalidCredentialsException.java
Content: 
package com.todoapp.common.exception;

public class InvalidCredentialsException extends BusinessException {
    public InvalidCredentialsException() {
        super(ErrorCode.INVALID_CREDENTIALS);
    }
}


File: 
src/main/java/com/todoapp/common/security/CustomUserDetailService.java
Content: 
package com.todoapp.common.security;

import com.todoapp.dataaccess.entity.User;
import com.todoapp.dataaccess.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CustomUserDetailService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username));

        return new CustomUserDetails(user);
    }
}


File: 
src/main/java/com/todoapp/common/security/CustomUserDetails.java
Content: 
package com.todoapp.common.security;

import com.todoapp.dataaccess.entity.User;
import java.util.Collection;
import java.util.Collections;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

@Getter
@RequiredArgsConstructor
public class CustomUserDetails implements UserDetails {

    private final User user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(new SimpleGrantedAuthority("ROLE_USER"));
    }

    @Override
    public String getUsername() {
        // Spring Security는 username을 식별자로 사용
        // email -> username으로 사용
        return user.getEmail();
    }

    @Override
    public @Nullable String getPassword() {
        return user.getPassword();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;  // 계정 만료 기능 없음
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;  // 계정 잠금 기능 없음
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;  // 비밀번호 만료 기능 없음
    }

    @Override
    public boolean isEnabled() {
        return true;  // 계정 활성화 여부 (이메일 인증 등)
    }

    // User Entity에 직접 접근할 수 있는 메서드
    public Long getUserId() {
        return user.getId();
    }

    public String getName() {
        return user.getName();
    }

    public String getEmail() {
        return user.getEmail();
    }
}


File: 
src/main/java/com/todoapp/dataaccess/config/PasswordEncoderConfig.java
Content: 
package com.todoapp.dataaccess.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordEncoderConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


File: 
src/main/java/com/todoapp/dataaccess/entity/BaseEntity.java
Content: 
package com.todoapp.dataaccess.entity;

import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;

@Getter
@MappedSuperclass
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}


File: 
src/main/java/com/todoapp/dataaccess/entity/BaseTimeEntity.java
Content: 
package com.todoapp.dataaccess.entity;

import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import java.time.Instant;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseTimeEntity extends BaseEntity {

    @CreatedDate
    Instant createdDate;

    @LastModifiedDate
    Instant updatedDate;
}


File: 
src/main/java/com/todoapp/dataaccess/entity/Todo.java
Content: 
package com.todoapp.dataaccess.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Todo extends BaseTimeEntity {

    @Column(nullable = false)
    private String title;

    private String description;

    private boolean completed;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;


    public Todo(String title, String description) {
        this.title = title;
        this.description = description;
        this.completed = false;
    }

    public Todo(String title, String description, User user) {
        this.title = title;
        this.description = description;
        this.completed = false;
        this.user = user;
    }

    public void complete() {
        this.completed = true;
    }

    public void updateTitle(String title) {
        this.title = title;
    }
}


File: 
src/main/java/com/todoapp/dataaccess/entity/User.java
Content: 
package com.todoapp.dataaccess.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Pattern;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@Entity
@Table(name = "users")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User extends BaseTimeEntity {

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String phoneNumber;

    @Builder
    public User(String email, String password, String name, String phoneNumber) {
        this.email = email;
        this.password = password;
        this.name = name;
        this.phoneNumber = phoneNumber;
    }
}


File: 
src/main/java/com/todoapp/dataaccess/repository/TodoRepository.java
Content: 
package com.todoapp.dataaccess.repository;

import com.todoapp.dataaccess.entity.Todo;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long> {
    List<Todo> findByCompleted(boolean completed);

    List<Todo> findByTitleContaining(String title);
}


File: 
src/main/java/com/todoapp/dataaccess/repository/UserRepository.java
Content: 
package com.todoapp.dataaccess.repository;

import com.todoapp.dataaccess.entity.User;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByEmail(String email);

    boolean existsByEmail(String email);
}


File: 
src/main/java/com/todoapp/implement/validator/PasswordMatch.java
Content: 
package com.todoapp.implement.validator;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchValidator.class)
public @interface PasswordMatch {
    String message() default "비밀번호가 일치하지 않습니다.";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    String password() default "password";
    String passwordConfirm() default "passwordConfirm";

}


File: 
src/main/java/com/todoapp/implement/validator/PasswordMatchValidator.java
Content: 
package com.todoapp.implement.validator;

import com.todoapp.pressentation.dto.request.SignUpRequest;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PasswordMatchValidator implements ConstraintValidator<PasswordMatch, SignUpRequest> {

    @Override
    public boolean isValid(SignUpRequest request, ConstraintValidatorContext context) {
        if (request.getPassword() == null || request.getPasswordConfirm() == null) {
            return true;
        }

        return request.getPassword().equals(request.getPasswordConfirm());
    }
}


File: 
src/main/java/com/todoapp/pressentation/controller/AuthController.java
Content: 
package com.todoapp.pressentation.controller;

import com.todoapp.dataaccess.entity.User;
import com.todoapp.pressentation.dto.request.LoginRequest;
import com.todoapp.pressentation.dto.request.SignUpRequest;
import com.todoapp.pressentation.dto.response.LoginResponse;
import com.todoapp.pressentation.dto.response.SignUpResponse;
import com.todoapp.business.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserService userService;

    @PostMapping("/signup")
    public ResponseEntity<SignUpResponse> signUp(@Valid @RequestBody SignUpRequest request) {
        User user = userService.signUp(request);

        SignUpResponse response = SignUpResponse.from(user);

        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(response);
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        LoginResponse response = userService.login(request);
        return ResponseEntity.ok(response);
    }
}


File: 
src/main/java/com/todoapp/pressentation/controller/TodoController.java
Content: 
package com.todoapp.pressentation.controller;

import com.todoapp.business.service.TodoService;
import com.todoapp.pressentation.dto.request.TodoCreateRequest;
import com.todoapp.pressentation.dto.response.TodoResponse;
import jakarta.validation.Valid;
import java.util.List;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/todos")
@RequiredArgsConstructor
public class TodoController {

    private final TodoService todoService;

    @PostMapping
    public ResponseEntity<TodoResponse> createTodo(@Valid @RequestBody TodoCreateRequest request) {
        TodoResponse response = todoService.createTodo(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    public ResponseEntity<List<TodoResponse>> findAll() {
        List<TodoResponse> responses = todoService.findAll();
        return ResponseEntity.ok(responses);
    }

    @GetMapping("/{id}")
    public ResponseEntity<TodoResponse> findById(@PathVariable Long id) {
        TodoResponse response = todoService.findById(id);
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{id}/complete")
    public ResponseEntity<Void> completeTodo(@PathVariable Long id) {
        todoService.completeTodo(id);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTodo(@PathVariable Long id) {
        todoService.deleteTodo(id);
        return ResponseEntity.noContent().build();
    }
}


File: 
src/main/java/com/todoapp/pressentation/dto/request/LoginRequest.java
Content: 
package com.todoapp.pressentation.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {

    @NotBlank(message = "이메일은 필수입니다")
    @Email
    private String email;

    @NotBlank(message = "비밀번호는 필수입니다.")
    private String password;
}


File: 
src/main/java/com/todoapp/pressentation/dto/request/SignUpRequest.java
Content: 
package com.todoapp.pressentation.dto.request;


import com.todoapp.implement.validator.PasswordMatch;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@PasswordMatch()
public class SignUpRequest {

    @NotBlank(message = "이메일은 필수입니다.")
    @Email(message = "이메일 형식이 올바르지 않습니다.")
    private String email;

    @NotBlank(message = "비밀번호는 필수입니다.")
    @Size(min = 8, max = 20, message = "비밀번호는 8자 이상 20자 이하여야 합니다.")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*(),.?\":{}|<>]).{8,20}$",
            message = "비밀번호는 8~20자의 대문자, 소문자, 숫자, 특수문자를 포함해야 합니다.")
    private String password;

    @NotBlank(message = "비밀번호 확인은 필수입니다.")
    private String passwordConfirm;

    @NotBlank(message = "이름은 필수입니다.")
    @Size(min = 2, max = 10, message = "이름은 2자 이4상 10자 이하여야 합니다")
    private String name;

    @NotBlank(message = "전화번호는 필수입니다.")
    @Pattern(regexp = "^01[0-9]-[0-9]{4}-[0-9]{4}$",
            message = "전화번호 형식이 올바르지 않습니다. (예: 010-1234-1234")
    private String phoneNumber;
}


File: 
src/main/java/com/todoapp/pressentation/dto/request/TodoCreateRequest.java
Content: 
package com.todoapp.pressentation.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
@AllArgsConstructor
public class TodoCreateRequest {

    @NotBlank(message = "제목은 필수입니다")
    @Size(min = 1, max = 50, message = "제목은 1자 이상 50자 이하여야 합니다.")
    private String title;

    @Size(max = 500, message = "설명은 500자 이하여야 합니다.")
    private String description;

}


File: 
src/main/java/com/todoapp/pressentation/dto/response/ErrorResponse.java
Content: 
package com.todoapp.pressentation.dto.response;

import com.todoapp.common.exception.ErrorCode;
import java.time.Instant;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class ErrorResponse {

    private String code;
    private String message;
    private Instant timestamp;
    private Map<String, String> errors;

    public static ErrorResponse of(ErrorCode errorCode) {
        return new ErrorResponse(
                errorCode.getCode(),
                errorCode.getMessage(),
                Instant.now(),
                null
        );
    }

    public static ErrorResponse of(ErrorCode errorCode, String message) {
        return new ErrorResponse(
                errorCode.getCode(),
                message,
                Instant.now(),
                null
        );
    }

    public static ErrorResponse of(String code, String message, Map<String, String> errors) {
        return new ErrorResponse(
                code,
                message,
                Instant.now(),
                errors
        );
    }
}


File: 
src/main/java/com/todoapp/pressentation/dto/response/LoginResponse.java
Content: 
package com.todoapp.pressentation.dto.response;

import com.todoapp.dataaccess.entity.User;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class LoginResponse {
    private Long id;
    private String email;
    private String name;
    private String message;

    public static LoginResponse of(User user) {
        return new LoginResponse(
                user.getId(),
                user.getEmail(),
                user.getName(),
                "로그인에 성공했습니다."
        );
    }
}


File: 
src/main/java/com/todoapp/pressentation/dto/response/SignUpResponse.java
Content: 
package com.todoapp.pressentation.dto.response;

import com.todoapp.dataaccess.entity.User;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class SignUpResponse {

    private Long id;
    private String email;
    private String name;
    private String message;

    public static SignUpResponse from(User user) {
        return new SignUpResponse(
                user.getId(),
                user.getEmail(),
                user.getName(),
                "회원가입이 완료되었습니다."
        );
    }
}


File: 
src/main/java/com/todoapp/pressentation/dto/response/TodoResponse.java
Content: 
package com.todoapp.pressentation.dto.response;

import com.todoapp.dataaccess.entity.Todo;
import java.time.Instant;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class TodoResponse {

    private Long id;
    private String title;
    private String description;
    private boolean completed;
    private Instant createdAt;

    public static TodoResponse from(Todo todo) {
        return new TodoResponse(
                todo.getId(),
                todo.getTitle(),
                todo.getDescription(),
                todo.isCompleted(),
                todo.getCreatedDate()
        );
    }
}


File: 
src/main/java/com/todoapp/pressentation/exception/GlobalExceptionHandler.java
Content: 
package com.todoapp.pressentation.exception;

import com.todoapp.common.exception.BusinessException;
import com.todoapp.common.exception.ErrorCode;
import com.todoapp.pressentation.dto.response.ErrorResponse;
import java.util.HashMap;
import java.util.Map;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final String VALIDATION_ERROR_CODE = "C001";
    private static final String VALIDATION_ERROR_MESSAGE = "입력값 검증에 실패했습니다.";

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        Map<String, String> errors = new HashMap<>();
        BindingResult bindingResult = e.getBindingResult();

        if (bindingResult.hasFieldErrors()) {
            bindingResult.getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage())
            );
        }

        if (bindingResult.hasGlobalErrors()) {
            bindingResult.getGlobalErrors().forEach(error ->
                errors.put(error.getObjectName(), error.getDefaultMessage())
            );
        }

        ErrorCode errorCode = ErrorCode.INVALID_INPUT_VALUE;
        return ResponseEntity
                .status(errorCode.getStatus())
                .body(ErrorResponse.of(VALIDATION_ERROR_CODE, VALIDATION_ERROR_MESSAGE, errors));
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        ErrorCode errorCode = e.getErrorCode();
        return ResponseEntity
                .status(errorCode.getStatus())
                .body(ErrorResponse.of(errorCode, e.getMessage()));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException e) {
        ErrorCode errorCode = ErrorCode.TODO_NOT_FOUND;
        return ResponseEntity
                .status(errorCode.getStatus())
                .body(ErrorResponse.of(errorCode.getCode(), e.getMessage(), null));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        ErrorCode errorCode = ErrorCode.INTERNAL_SERVER_ERROR;
        return ResponseEntity
                .status(errorCode.getStatus())
                .body(ErrorResponse.of(errorCode));
    }
}


File: 
src/main/java/test/Application.java
Content: 
package test;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}


File: 
src/main/java/test/ErrorResponse.java
Content: 
package test;


import java.time.LocalDateTime;
import java.util.Map;
import lombok.Getter;

@Getter
public class ErrorResponse {
    private final String code;
    private final String message;
    private final Map<String, String> errors;
    private final LocalDateTime timestamp;

    public ErrorResponse(String code, String message, Map<String, String> errors) {
        this.code = code;
        this.message = message;
        this.errors = errors;
        this.timestamp = LocalDateTime.now();
    }
}


File: 
src/main/java/test/GlobalExceptionHandler.java
Content: 
package test;

import java.util.HashMap;
import java.util.Map;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse errorResponse = new ErrorResponse(
                "VALIDATION_FAILED",
                "입력값 검증에 실패했습니다",
                errors
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException ex) {
        ErrorResponse errorResponse = new ErrorResponse(
                "INVALID_ARGUMENT",
                ex.getMessage(),
                null
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse(
                "INTERNAL_SERVER_ERROR",
                "서버 내부 오류가 발생했습니다",
                null
        );

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(errorResponse);
    }
}


File: 
src/main/java/test/SignUpRequest.java
Content: 
package test;

public class SignUpRequest {
}


File: 
src/main/java/test/Todo.java
Content: 
package test;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import java.time.LocalDateTime;
import lombok.Getter;

@Entity
@Getter
public class Todo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    private String description;

    private boolean completed;

    private LocalDateTime createdAt;

    protected Todo() {
    }

    public Todo(String title, String description) {
        this.title = title;
        this.description = description;
        this.completed = false;
        this.createdAt = LocalDateTime.now();
    }

    public void complete() {
        this.completed = true;
    }

    public void updateTitle(String title) {
        this.title = title;
    }
}


File: 
src/main/java/test/TodoController.java
Content: 
package test;

import jakarta.validation.Valid;
import java.util.List;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("api/todos")
@AllArgsConstructor
public class TodoController {

    private final TodoService todoService;

    @PostMapping
    public ResponseEntity<Long> create(@Valid @RequestBody TodoCreateRequest request) {
        Long todo = todoService.createTodo(request.getTitle(), request.getDescription());
        return ResponseEntity.ok(todo);
    }

    @GetMapping
    public ResponseEntity<List<TodoResponse>> findAll() {
        List<Todo> todos = todoService.findAll();
        List<TodoResponse> response = todos.stream()
                .map(TodoResponse::from)
                .toList();
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<TodoResponse> findById(@RequestParam Long id) {
        Todo todo = todoService.findById(id);
        return ResponseEntity.ok(TodoResponse.from(todo));
    }

    @PatchMapping("/{id}/complete")
    public ResponseEntity<Void> complete(@PathVariable Long id) {
        todoService.completeTodo(id);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteById(@PathVariable Long id) {
        todoService.deleteTodo(id);
        return ResponseEntity.ok().build();
    }
}


File: 
src/main/java/test/TodoCreateRequest.java
Content: 
package test;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
public class TodoCreateRequest {

    @NotBlank(message = "제목은 필수입니다")
    @Size(min = 1, max = 50, message = "제목은 1자 이상 50자 이하여야 합니다.")
    private String title;

    @Size(max = 500, message = "설명은 500자 이하여야 합니다.")
    private String description;

}


File: 
src/main/java/test/TodoRepository.java
Content: 
package test;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long> {
    List<Todo> findByCompleted(boolean completed);

    List<Todo> findByTitleContaining(String title);
}


File: 
src/main/java/test/TodoResponse.java
Content: 
package test;

import java.time.LocalDateTime;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class TodoResponse {

    private Long id;
    private String title;
    private String description;
    private boolean completed;
    private LocalDateTime createdAt;

    public static TodoResponse from(Todo todo) {
        return new TodoResponse(
                todo.getId(),
                todo.getTitle(),
                todo.getDescription(),
                todo.isCompleted(),
                todo.getCreatedAt()
        );
    }
}


File: 
src/main/java/test/TodoService.java
Content: 
package test;

import java.util.List;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional(readOnly = true)
@AllArgsConstructor
public class TodoService {

    private final TodoRepository todoRepository;

    @Transactional
    public Long createTodo(String title, String description) {
        Todo todo = new Todo(title, description);
        Todo saved = todoRepository.save(todo);
        return saved.getId();
    }

    public Todo findById(Long id) {
        return todoRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Todo not found " + id));
    }

    public List<Todo> findAll() {
        return todoRepository.findAll();
    }

    @Transactional
    public void completeTodo(Long id) {
        Todo todo = findById(id);
        todo.complete();
    }

    @Transactional
    public void deleteTodo(Long id) {
        Todo todo = findById(id);
        todoRepository.deleteById(id);
    }
}


File: 
src/main/java/test/User.java
Content: 
package test;

public class User {
}


File: 
src/main/java/test/UserRepository.java
Content: 
package test;

public class UserRepository {
}


File: 
src/main/resources/application.yml
Content: 
spring:
  application:
    name: spring.test

  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:

  h2:
    console:
      enabled: true  # http://localhost:8080/h2-console 에서 DB 확인 가능

  jpa:
    hibernate:
      ddl-auto: create  # 애플리케이션 시작 시 테이블 자동 생성
    show-sql: true      # SQL 로그 출력
    properties:
      hibernate:
        format_sql: true  # SQL 이쁘게 출력


File: 
src/main/resources/templates
Content: 
empty directory

File: 
src/test/java/com/todoapp/ApplicationTests.java
Content: 
package com.todoapp;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

	@Test
	void contextLoads() {
	}

}


File: 
src/test/java/com/todoapp/Integration/TodoIntegrationTest.java
Content: 
package com.todoapp;

import static org.assertj.core.api.Assertions.*;

import com.todoapp.dataaccess.entity.Todo;
import com.todoapp.pressentation.dto.request.TodoCreateRequest;
import com.todoapp.pressentation.dto.response.TodoResponse;
import com.todoapp.dataaccess.repository.TodoRepository;
import com.todoapp.business.service.TodoService;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@Transactional
public class TodoIntegrationTest {

    @Autowired
    private TodoRepository todoRepository;

    @Autowired
    private TodoService todoService;

    @Test
    @DisplayName("정상적인 요청으로 Todo 생성 성공")
    void createTodo_WithValidRequest_Success() {
        TodoCreateRequest request = new TodoCreateRequest("스프링 공부", "JPA 학습하기");

        TodoResponse response = todoService.createTodo(request);

        assertThat(response.getId()).isNotNull();
        assertThat(response.getTitle()).isEqualTo("스프링 공부");
        assertThat(response.isCompleted()).isFalse();

        Todo savedTodo = todoRepository.findById(response.getId()).orElseThrow();
        assertThat(savedTodo.getTitle()).isEqualTo(response.getTitle());
    }

    @Test
    @DisplayName("설명 없이 Todo 생성 성공")
    void createTodo_WithOutDescription_Success() {
        TodoCreateRequest request = new TodoCreateRequest("제목만 있는 Todo", null);

        TodoResponse response = todoService.createTodo(request);

        assertThat(response.getTitle()).isEqualTo("제목만 있는 Todo");
        assertThat(response.getDescription()).isNull();
    }


    @Test
    @DisplayName("ID로 Todo 조회 성공")
    void findById_WithExistingId_Success() {
        TodoCreateRequest request = new TodoCreateRequest("테스트 Todo", "설명");
        TodoResponse created = todoService.createTodo(request);

        TodoResponse foundId = todoService.findById(created.getId());

        assertThat(foundId.getId()).isEqualTo(created.getId());
        assertThat(foundId.getTitle()).isEqualTo(created.getTitle());
    }

    @Test
    @DisplayName("존재하지 않는 ID 조회 시 예외 발생")
    void findById_NotExistingId_ThrowsException() {
        Long nonExistingId = 999L;

        assertThatThrownBy(() -> todoService.findById(nonExistingId))
                .isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("전체 Todo 목록 조회")
    void findAll_ReturnsAllTodos() {
        todoService.createTodo(new TodoCreateRequest("Todo 1", "설명 1"));
        todoService.createTodo(new TodoCreateRequest("Todo 2", "설명 2"));
        todoService.createTodo(new TodoCreateRequest("Todo 3", "설명 3"));

        List<TodoResponse> todos = todoService.findAll();

        assertThat(todos).hasSize(3);
        assertThat(todos).extracting("title")
                .containsExactlyInAnyOrder("Todo 1", "Todo 3", "Todo 2");
    }

    @Test
    @DisplayName("Todo 완료 처리 성공")
    void createTodo_Success() {
        TodoResponse createTodo = todoService.createTodo(new TodoCreateRequest("테스트", null));

        todoService.completeTodo(createTodo.getId());

        Todo todo = todoRepository.findById(createTodo.getId()).orElseThrow();
        assertThat(todo.isCompleted()).isTrue();
    }

    @Test
    @DisplayName("존재하지 않은 Todo 완료 시 예외 발생")
    void createTodo_WithNonExistingId_ThrowsException() {
        final Long nonExistingId = 999L;

        assertThatThrownBy(() -> todoService.completeTodo(nonExistingId))
                .isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("Todo 삭제 성공")
    void deleteTodo_Success() {
        TodoResponse createTodo = todoService.createTodo(new TodoCreateRequest("테스트 성공!", null));

        todoService.deleteTodo(createTodo.getId());

        assertThatThrownBy(() -> todoService.findById(createTodo.getId()))
                .isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("Todo 생성 -> 완료 -> 조회 전체 플로우")
    void todo_FullFlow_CreateCompleted_Success() {
        TodoResponse createTodo = todoService.createTodo(new TodoCreateRequest("테스트 Todo", null));

        todoService.completeTodo(createTodo.getId());

        TodoResponse response = todoService.findById(createTodo.getId());
        assertThat(response.isCompleted()).isTrue();
        assertThat(response.getTitle()).isEqualTo("테스트 Todo");
    }
}


File: 
src/test/java/com/todoapp/Integration/UserLoginIntegrationTest.java
Content: 
package com.todoapp.Integration;

import static org.assertj.core.api.Assertions.*;

import com.todoapp.business.service.UserService;
import com.todoapp.common.exception.InvalidCredentialsException;
import com.todoapp.dataaccess.repository.UserRepository;
import com.todoapp.pressentation.dto.request.LoginRequest;
import com.todoapp.pressentation.dto.request.SignUpRequest;
import com.todoapp.pressentation.dto.response.LoginResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.crossstore.ChangeSetPersister.NotFoundException;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@Transactional
public class UserLoginIntegrationTest {

    @Autowired
    private UserService userService;

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        SignUpRequest request = SignUpRequest.builder()
                .email("kss8014@gmail.com")
                .password("Password123@")
                .passwordConfirm("Password123@")
                .name("강두기")
                .phoneNumber("010-9203-5808")
                .build();

        userService.signUp(request);
    }

    @Test
    @DisplayName("올바른 이메일과 비밀번호로 로그인 성공")
    void login_WithValidCredentials_Success() {
        // given
        LoginRequest request = new LoginRequest("kss8014@gmail.com", "Password123@");

        // when
        LoginResponse response = userService.login(request);

        // then
        assertThat(response.getEmail()).isEqualTo("kss8014@gmail.com");
        assertThat(response.getName()).isEqualTo("강두기");
        assertThat(response.getMessage()).isEqualTo("로그인에 성공했습니다.");
    }

    @Test
    @DisplayName("존재하지 않은 이메일로 로그인 시도 시 실패")
    void login_WithNonExistentEmail_Fail() {
        // given
        LoginRequest request = new LoginRequest("test123@gmail.com", "Password123@");

        // when & then
        assertThatThrownBy(() -> userService.login(request))
                .isInstanceOf(InvalidCredentialsException.class)
                .hasMessageContaining("이메일 또는 비밀번호가 일치하지 않습니다.");
    }

    @Test
    @DisplayName("잘못된 비밀번호로 로그인 시도 시 실패")
    void login_WithWrongPassword_Fail() {
        // given
        LoginRequest request = new LoginRequest("kss8014@gmail.com", "TestPassword123@");

        // when & then
        assertThatThrownBy(() -> userService.login(request))
                .isInstanceOf(InvalidCredentialsException.class)
                .hasMessageContaining("이메일 또는 비밀번호가 일치하지 않습니다.");
    }

    @Test
    @DisplayName("로그인 성공 후 반환된 userId가 올바른지 확인")
    void login_Success_ReturnCorrectUserId() {
        // given
        LoginRequest request = new LoginRequest("kss8014@gmail.com", "Password123@");

        // when
        LoginResponse response = userService.login(request);

        assertThat(userRepository.findById(response.getId())).isPresent();
    }
}


File: 
src/test/java/com/todoapp/Integration/UserSignUpIntegrationTest.java
Content: 
package com.todoapp;

import static org.assertj.core.api.Assertions.*;

import com.todoapp.dataaccess.entity.User;
import com.todoapp.pressentation.dto.request.SignUpRequest;
import com.todoapp.dataaccess.repository.UserRepository;
import com.todoapp.business.service.UserService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@Transactional
class UserSignUpIntegrationTest {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    @Test
    @DisplayName("회원가입 성공 테스트")
    void 회원가입_성공_테스트() {
        SignUpRequest request = SignUpRequest.builder()
                .email("test123@gmail.com")
                .password("Password123!")
                .passwordConfirm("Password123!")
                .name("강두기")
                .phoneNumber("010-1234-1234")
                .build();

        User user = userService.signUp(request);

        User savedUser = userRepository.findById(user.getId()).orElseThrow();
        assertThat(savedUser.getName()).isEqualTo("강두기");
        assertThat(savedUser.getEmail()).isEqualTo("test123@gmail.com");

        assertThat(savedUser.getPassword()).isNotEqualTo("Password123!");
        assertThat(savedUser.getPassword()).startsWith("$2a$");
    }

    @Test
    @DisplayName("회원가입 후 중복 이메일로 재가입 시 실패")
    void signUp_ThenDuplicateEmail_Fail() {
        SignUpRequest first = SignUpRequest.builder()
                .email("test123@gmail.com")
                .password("Password123!")
                .passwordConfirm("Password123!")
                .name("강두기")
                .phoneNumber("010-1234-1234")
                .build();

        userService.signUp(first);

        SignUpRequest second = SignUpRequest.builder()
                .email("test123@gmail.com")
                .password("Password123!")
                .passwordConfirm("Password123!")
                .name("강맑음")
                .phoneNumber("010-1234-1234")
                .build();

        assertThatThrownBy(() -> userService.signUp(second))
                .isInstanceOf(IllegalArgumentException.class);

        assertThat(userRepository.count()).isEqualTo(1);
    }
}


File: 
src/test/java/com/todoapp/TodoValidationTest.java
Content: 
package com.todoapp;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.todoapp.pressentation.dto.request.TodoCreateRequest;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import tools.jackson.databind.ObjectMapper;

@SpringBootTest
@AutoConfigureMockMvc
public class TodoValidationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("제목이 비어있으면 검증 실패")
    void createTodo_WithBlankTitle_ShouldFail() throws Exception {

        TodoCreateRequest request = new TodoCreateRequest();

        String requestBody = objectMapper.writeValueAsString(request);

        mockMvc.perform(post("/api/todos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.code").value("C001"))
                .andExpect(jsonPath("$.errors.title").exists());
    }

    @Test
    @DisplayName("제목이 50자를 초과할 경우 검증 실패")
    void createTodo_WithLongTitle_ShouldFail() throws Exception {
        String longTitle = "a".repeat(51);

        String requestBody = """
                {
                    "title": "%s",
                    "description": "테스트"
                }
                """.formatted(longTitle);

        mockMvc.perform(post("/api/todos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.code").value("C001"))
                .andExpect(jsonPath("$.errors.title").exists());

    }
}


File: 
src/test/java/com/todoapp/common/config/SecurityConfigTest.java
Content: 
package com.todoapp.common.config;


import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.todoapp.pressentation.dto.request.TodoCreateRequest;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class SecurityConfigTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("회원가입 API는 인증 없이 접근 가능")
    void signupEndPoint_WithoutAuthentication_ShouldBeAccessible() throws Exception {
        String body = """
                {
                    "email": "test123@gmail.com",
                    "password": "Password123@",
                    "passwordConfirm": "Password123@",
                    "name": "강두기",
                    "phoneNumber": "010-1234-1234"
                }
                """;

        mockMvc.perform(post("/api/auth/signup")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(body))
                .andExpect(status().isCreated());
    }

    @Test
    @DisplayName("로그인 API는 인증 없이 접근 가능")
    void loginEndPoint_WithoutAuthentication_ShouldBeAccessible() throws Exception {
        String body = """
                {
                    "email": "test123@gmail.com",
                    "password": "Password123@",
                    "passwordConfirm": "Password123@",
                    "name": "강두기",
                    "phoneNumber": "010-1234-1234"
                }
                """;

        mockMvc.perform(post("/api/auth/signup")
                .contentType(MediaType.APPLICATION_JSON)
                .content(body));

        String login = """
                {
                    "email": "test123@gmail.com",
                    "password": "Password123@"
                }
                """;

        mockMvc.perform(post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(login))
                .andExpect(status().isOk());
    }

    @Test
    @DisplayName("TODO API 인증 없이 접근 불가 (401 Unauthorized)")
    void todoEndPoint_WithoutAuthentication_ShouldReturn401() throws Exception {
        mockMvc.perform(get("/api/todos"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("TODO 생성 API도 인증 없이 접근 불가 (401)")
    void createTodoEndPoint_WithoutAuthentication_ShouldReturn401() throws Exception {
        String createTodo = """
                {
                    "title": "테스트 코드",
                    "description": "Hello"
                }
                """;

        mockMvc.perform(post("/api/todos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(createTodo))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("TODO 조회 API도 인증 없이 접근 불가 (401)")
    void findTodoEndPoint_WithoutAuthentication_ShouldReturn401() throws Exception {
        mockMvc.perform(get("/api/todos/1"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("TODO 삭제 API도 인증 없이 접근 불가 (401)")
    void deleteTodoEndPoint_WithoutAuthentication_ShouldReturn401() throws Exception {
        mockMvc.perform(delete("/api/todos/1"))
                .andExpect(status().isUnauthorized());
    }
}

File: 
src/test/java/com/todoapp/controller/AuthControllerTest.java
Content: 
import static org.junit.jupiter.api.Assertions.*;
class AuthControllerTest {
  
}

File: 
src/test/java/test/ApplicationTests.java
Content: 
package test;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

	@Test
	void contextLoads() {
	}

}


File: 
src/test/java/test/TodoValidationTest.java
Content: 
package test;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import tools.jackson.databind.ObjectMapper;

@SpringBootTest
@AutoConfigureMockMvc
public class TodoValidationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("제목이 비어있으면 검증 실패")
    void createTodo_WithBlankTitle_ShouldFail() throws Exception {

        TodoCreateRequest request = new TodoCreateRequest();

        String requestBody = objectMapper.writeValueAsString(request);

        mockMvc.perform(post("/api/todos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andDo(print())
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.code").value("VALIDATION_FAILED"))
                .andExpect(jsonPath("$.errors.title").exists());
    }
}


File: 
src/test/resources
Content: 
empty directory

